.. highlight:: clojure

闭包简介
===========

几种闭包
---------------------

闭包（closure）一词有多种用法，人们常说的闭包可能是：

1）数学上的闭包

2）词法作用域闭包

3）组合操作的闭包性质

这篇文章只介绍后两种，主要介绍第二种，
因为它是编程中最常见的闭包定义。

当我只说『闭包』的时候，指的就是第二种闭包。

示例代码所用的语言为 Clojure 。


闭包的最简定义
-----------------

闭包，又名环境捕捉（environment capture），
它指的是，在进行函数定义时，将定义所在的环境（environment）包含在函数当中。

比如以下例子就将 ``x`` 、 ``y`` 、 ``z`` 三个变量闭包进了匿名函数中：

::

    (let [x 0
          y 1 
          z 2]
        (fn []
            (+ x y z))))

这个匿名函数的执行结果为 ``3`` 。


作用域与闭包
----------------

闭包的完整名称叫做『词法作用域闭包』（lexically scoped closure）。

作用域是指：一个变量在程序中的有效范围。

作为例子，考察一个函数定义，
函数的参数（parameters）的作用域就是整个函数体（body）：

::

    (fn [x y z]         
        ; x, y, z 的作用域开始
        (println x)     
        (println y)
        (println z)
        ; x, y, z 的作用域结束
    )

另一种重要的作用域是词法作用域(lexically scope)，
它指的是：一个变量的值由源码中最靠近（innermost）的定义决定。

例子：

::

    (let [x 3.14]
        (let [x 10086]
            (println x)))

在上面的这个例子里，
最接近表达式 ``(println x)`` 的 ``x`` 定义为 ``(let [x 10086] ...)`` ，
因此，这个表达式的将打印出值 ``10086`` 。

好的，既然说明了词法作用域，那么是时候说说这个『词法作用域闭包』的意思了。

一个词法作用域闭包指的是：当定义一个函数时，
这个函数捕捉的是函数定义所处的词法作用域环境，
而不是运行它的那个环境。

举个例子：

::

    (def p
        (let [x 10086]
            (fn []
                (println x))))

    (let [x 3.14]
        (p))

``(p)`` 的执行结果将打印出 ``10086`` ，
而不是 ``3.14`` 。


自由变量与外部环境
----------------------

既然说完了闭包的定义，现在来说说闭包所捕捉的环境在什么情况下会用上。

在环境中，将某个变量和某个值关联起来，这一动作称之为绑定（binding）：

::

    (def x 10086)       ; 创建一个 root binding （类似其他语言的全局变量）

    (let [x 10086]      ; 创建一个局部变量，并绑定它
        ; ...
    )

如果一个变量未被绑定，也即是，这个变量在所处的环境中没有和它相对应的值，
那么这个变量被称为『自由变量』（free variable）。

比如在下面的例子中， ``y`` 就是一个自由变量：

::

    (let [x 10]
        (+ x y))

自由变量当然也可以存在于函数当中：

::

    (fn [x]
        (+ x y))

当求值器对函数内的一个自由变量进行求值时，
它会发现在当前的环境里没办法找到这个变量的值，
于是它会到这个函数所处环境的外围环境（enclosing environment）去继续查找变量的值，
直到找到一个能用的绑定为止；

又或者，求值器一直回溯到最外层环境（全局环境，global environment），
但仍找不到所需的绑定，这时只能抛出一个错误，
遗憾地说明找不到变量的值。

一个函数的外围环境，就是它定义时所闭包的那个环境。

举个例子：

::

    ; 全局环境 GE
    (def f                          
        (let [x 10086]              ; 环境 E1 开始，闭包全局环境 GE
            (let [y 3.14]           ; 环境 E2 开始，闭包 E1
                (let [z 2.7]        ; 环境 E3 开始，闭包 E2
                    (fn []          ; 环境 E4 开始，闭包 E3
                        x
                    )               ; 环境 E4 结束
                )                   ; 环境 E3 结束
            )                       ; 环境 E2 结束
        )                           ; 环境 E1 结束
    )
    ; 全局环境 GE 

在函数 ``f`` 中，环境 E4 闭包了 E3 ，
E3 闭包了 E2 ， E2 闭包了 E1 ，而 E1 闭包了全局环境 GE 。

考虑求值 ``(f)`` 的时候会发生什么事：
求值器试图在 E4 查找变量 ``x`` 的绑定，未果，
于是它转到 E4 闭包的外围环境 E3 继续寻找 ``x`` ，
但是 E3 也没有 ``x`` 的绑定，
一直这样做下去，直到在 E1 ，终于找到了 ``x`` 的绑定，
于是求值器返回 ``x`` 的值 ``10086`` 作为函数 ``f`` 的值。

嗯，可能是最后一个关于词法闭包的问题，
那就是，为什么 ``let`` 也能创建闭包？

答案是：因为 ``let`` 实际上也会创建一个匿名函数。

比如上面的函数 ``f`` 的定义就可以转换成：

::

    (def f
        (fn []
            ((fn [x] 
                ((fn [y] 
                    ((fn [z] 
                        x)  
                    2.7))       ; 应用 2.7 到 z 
                3.14))          ; 应用 3.14 到 y
            10086)              ; 应用 10086 到 x
        )   
    )


Lisp 真有趣，不是嘛。。。


组合操作的闭包性质
------------------

某种组合数据对象的操作满足闭包性质，那就是说，
通过它组合起数据对象得到的结果本身还可以通过同样的操作进行再组合。

``cons`` 函数就是闭包性质的一个例子，
通过它创建的序对（pair）可以继续使用 ``cons`` 来组合：

::

    user=> (cons 3 '())
    (3)

    user=> (cons 2 (cons 3 '()))
    (2 3)

    user=> (cons 1 (cons 2 (cons 3 '())))
    (1 2 3)
    {% endhighlight %}

另外， ``vector`` 函数也满足闭包性质：

::

    user=> (vector 1 2 3)      
    [1 2 3]

    user=> (vector (vector 1 2 3) (vector 4 5 6) (vector 7 8 9))
    [[1 2 3] [4 5 6] [7 8 9]]

在现代的编程语言中，
这种闭包性质对于处理数据结构来说已经是基本的能力要求了。

所以，你可能根本就没听说过这个什么闭包性质，
但是你每天都在使用它：

- 当你创建一个列表的时候，你在利用这个性质；

- 当你创建一个矩阵的时候，你在利用这个性质；

- 当你创建一棵二叉树的时候，你在利用这个性质；

- 当你创建一个类中的类时，你在利用这个性质；

当你。。。好吧，总而言之，这个性质你每天都要用到，
恭喜你终于知道了它的正式名称！


总结
------

词法作用域闭包指的是：在进行函数定义时，将定义所在的环境（environment）包含在函数当中。

数据操作的闭包性质指的是：你每天处理数据结构时都要用到，但你从来就不知道它的名字的性质。


参考材料
------------

《计算机程序的构造和解释》 65-66 页， 162-163 页

《Concepts, Techniques, and Models of Computer Programming》 56-59 页， 65 页

《the Joy of Clojure》 7.2 节

`维基百科 closure 词条 <http://en.wikipedia.org/wiki/Closure_(computer_science)>`_ 
